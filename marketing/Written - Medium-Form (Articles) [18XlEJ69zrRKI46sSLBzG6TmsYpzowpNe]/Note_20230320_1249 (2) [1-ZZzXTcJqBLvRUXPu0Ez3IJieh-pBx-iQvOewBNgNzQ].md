

| Speaker 1: | Okay, so I wanted to take some time because Ricky asked me a question about why... He asked the question, why can a small website not keep up with volume of streaming video, but YouTube can? And why is it so expensive that it would take millions of dollars to scale up? Well, while I don't have the exact full in-depth reason in a way that I think I can articulate, I think one of the things that arose from that is, well, what is actual software? Because there's two ways that people think about software. One is people think about software from a very technical standpoint. In other words, you have a...  |
| :---- | :---- |
|  | They're kind of are two types of even programming languages. There's programming languages that are very linear, very step-by-step. The whole thing is a step-by-step, and that's called functional programming. Now, there's another way of programming, which is like... Yeah, well, and those functional instructions are the foundation of any programming. I mean, yes, there are other types of expressive languages, expression-based languages that are more whatever, but being that as it may, at the core, all language...  |
|  | Here's another interesting way to look at it. If you look at the evolution of software and the evolution of language, then you have the punch cards and then the assembly language. It's like, "Well, that's too too complicated. Let's find shorthand for that." But ultimately, everything was predominantly linear until somebody said, "Okay. Let's not make this completely linear. Let's say we're going to let you say, 'Go to...'" Well, I mean, maybe this is then from the beginning. "Go to step four and repeat." Okay. Well, that's good, but that's really complicated. How do I keep that in my head? And so then it's like, "Okay. Well, we're going to put names to this, so go to the part that's named, show error on the screen, and then let's go on the..." And then when it's done, then taking can set up to tell us to go somewhere else. And so we don't actually have to know the actual location. We can just refer to it by name. Then it's really easy.  |
|  | Then somebody said, "Okay. Well, then this is good, but we have to pass information back and forth. And so in order to do that, we need to have something called parameters. In other words, there's certain types of input and certain types of output that these things can have. And how do we define those? How do those get passed around?" And then they started creating a convention for that. And then they said, "Well, wait. It's actually not quite that simple, because now you have whole sets of functions that all work together." And how do those things tie together? Well, you have something called a class. That is a class. It's a collection of functions that share some information. And oh, by the way, there are some design patterns that are really important when you're working with classes, which is you can have... I mean, for example...  |
|  | Well, first of all, there's some design patterns with functions that are really important. For example, there are some contracts that you're going to keep. In other words, I'm only going to ask you to do this under these situations. I'm only going to tell you a certain subset of things. And then when you're done, you promise that the world will be in this kind of a state when you're done. And let's say with classes, this class is responsible for a conceptual part of the process. Now then this concept has been in software development for a very long time, even before it was called this, where it's like, well, what is a class? Well, a class often represents some kind of thing. So sometimes it's an abstract thing, and sometimes it's a more tangible thing.  |
|  | So for example, you want to start working with a file on disk. There's a series of operations that need to happen in order for you to do that. You need to let the operating system know that you want to open the file and you want to tell it what to do if the file doesn't exist. And you need to know what you're planning on doing with the file so you don't accidentally do the wrong thing with it so you can keep yourself from shooting yourself in the foot. And then once you do that, then you need to tell it what part of the file you want to go to. And then once you're in the right part of the file, then you need to tell it what you're going to either read or what you're going to write, or if you do both. And then you need to tell it that, "Okay, I'm done doing whatever I need to do with a file. I'm done with that. I'm not going to be doing anything more with that."  |
|  | And then it closes down access to it, and that gives the operating system a chance to go write these things to disks so that your information doesn't get lost. And it helps your operating system manage resources because even though it's a small amount, there's some bandwidth for it to be able to keep track of your file and the changes that you're making. Then once you've got that, then what's the next piece? Well, okay, so then these are all the types of things that you can set on a file. Oh, by the way, a file has attributes. You can set certain attributes, you can make it read only, you can look at certain statistical pieces of information, you can query it, find out when it was last modified.  |
|  | And these are all parts of accessing files. Well, oh, look at all these functions that do the same thing and they're all interconnected and interrelated. Well, conceptually, this is a class. And so we're going to create a class called a file that has all of these functions that it can have. Now, how does this actually relate with business? Well, first of all, there's all kinds of interesting things that are going on under the hood when you're working with the file that you don't actually need to know when you're working with a file. Nobody needs to know this information, but it's happening under the hood. So what does a class do? A class helps to hide that information from you so that ultimately when you want to work with the file, what do you need to know? You need to know the file name. You need to know some things about what you're going to be doing. And then you need to perform the actual actions.  |
|  | And so here's one of the lessons that we extract from business is that sometimes there's groups of activities that you're doing together that logically belong to each other, and you want them to be interconnected with each other. And because of that you can... Well, and so you can put them all under one roof and when somebody wants to go... And the way that you manage complexity is you limit the points of communication. So how do you limit the points of communication? Well, you only share the information that needs to be shared and you try to reduce the number of people that it needs to be shared with. And when you do that, you isolate and eliminate complexity. So you might have a sales department that's really complicated.  |
|  | We might have a marketing department that's extremely complicated and there's all these parts talking to each other. But what you do is you have parts within, you have any part of the business talks as much as it needs to with other people, but when you try to limit it to a single point of contact, you dramatically reduce complexity. What does this also mean? Well, systems and process are much more than just step by step in instructions. It's about finding the natural order and the natural structure that is emerging from within the organization. So now there's some patterns that we have. Well, there's some other issues too, which center around scalability. How do you scale software? Well, at some point you need to have have one source of truth for your information. You can't have two people out there with the same name and same social security number and different phone numbers because well then what are they? Which number is correct?  |
|  | And so let's say that you have a massive amount of storage, a massive amount of information that you're dealing with, and you need to synchronize this information across multiple people that are wanting to use it. Well how is that? Well, one of the ways that you do is... One of the things you can do is you say, "Okay, well it's perfectly appropriate to have somewhat stale information." So sometimes on a news website, just the act of saying that somebody is going to have one second stale news or that somebody's watching a streaming video that's one or two seconds delayed, introduces enough of a delay and enough of a capacity that it allows me to share the burden and speed it up. So in other words, so why is this? When you have only one source of information that's the source of truth, then you have two dozen people that are going to this one person and this one person gets over rooted because they only have so much bandwidth assault with this many people.  |
|  | Then you say, well no, that doesn't make sense. So in the case of software, instead of just having one computer to go to, we're going to have... That one computer is still going to be the source of truth, but it's going to share its information with six computers. And each of those six computers will have a copy of the information that's time delayed. And so every second, it's refreshing it to get the latest information. And then instead of 15 people going to... Or 18 people to the first person, you now have whatever the numbers are. You've got just a handful of people going to each one, so suddenly you've multiplied your capacity because you've introduced some kind of a delay. Now, what does this mean in business? Well, in business, sometimes you may have something that is the source of truth, like let's say the accounting, and maybe this is less true in a digital context, but it may be true from a procedural standpoint.  |
|  | So there is a master procedure list that gets handed down from department to department. And because there is a delay, then we are able to allow the... Then people can go ahead and instead of asking just one person and bombarding one person with all of these questions, they're actually able to go to multiple people and there's multiple sources of information for this. Now what's the problem with this in any kind of software environment? Well, one of the problems is that what happens when you have three copies of this information and the source of truth changes? So three computers have memorized my contact information and I changed the actual contact information. How do they know to update? Well, there's a few ways that they can do this. One, you can say, "Well, we just do this automatically every second." So if you catch it within a second, then you're going to get sale information.  |
|  | What does this mean in an organization? It may just mean that it takes time to roll out changes and whenever these changes get rolled out, then people get notified. And if you're okay with the delay, you're fine. Now what's another way to do it? Well, you can have a quick check-in that basically says, "Hey, I'm looking over this information, is it still up to date?" And if it is, then you go get it. Or you could say, "Well, every time we get this information we're going to go see, is this out of date? And if it is, then we're going to go fetch it ourselves and replace it."  |
|  | So there's a number of ways that you can actually deal with this issue. Or you can have whatever be... Or you can have a proactive state where when something is out of date, then it gets pushed down to... Then Then it's proactively gets pushed down. Or you can have a hybrid approach which is like, "Okay, there's a new policy, now we're going to go yank that policy out of the binder. And whenever you need a new one, you're going to come back and you're going to find a new one for us." And so that's how you deal with issues of scalability and how to prevent the duplication of information. Now, what you really want to avoid is you want to avoid duplication of... Listen, what you want to prevent the spread of misinformation. And the way that you prevent the spread of misinformation is by having only one source of true information.  |
|  | Now, what are some other parallels and equivalents? Well, another parallel and equivalent is there's something in software and there's something in the hardware side, which is short-term memory and long-term memory. Well, what happens when you unplug your computer? Well, ideally all that happens is all your programs close down and anything that was open in your programs then... Unless you're like Mac and you... Well, I mean maybe Mac doesn't even do this, but your program shuts down and then as a result of that, you lose all the information that you had open in your programs, but the files in your hard drive are safe. Now, there's some very specific timing situations where especially in olden days, if you cut power at the wrong time, then you might have a partially written file and the file wouldn't be valid. You might actually lose information on desk. But by and large, we solved that problem.  |
|  | And by the way, we now have batteries, which means that the loss of power is very unlikely. But nonetheless, a computer has a concept of short-term memory versus long-term memory. Well, what's the benefit of short-term memory? The benefit of short-term memory is that it's super, super fast. In other words, I mean if you're dealing with one of the fastest things... Well, as an example, when you have software, you might have a million lines. The project that we worked on had upwards of a million lines of code. And because of the way this stuff is interconnected, it might have ended up processing so about, I don't know exact numbers, but maybe five or 10 million lines of code because of, again, how the technical pieces of information happened under the hood. Now reading this much information off this ended up to be a bottleneck, especially at the point that you had that had a valid... Whenever your CPU, your processor was fast enough, then the slowdown would become reading all this information on this.  |
|  | Well, what's it analogous to? Ram is analogous to your short-term memory. And written procedures are analogous to long-term memory. So why do you need them? Well, short-term memory is good because it's really fast. But you can remember, but the problem is that there can be blips in your short-term memory and so that's when you need long-term memory. Or you might close down the program and somebody else might come up and log in and be like, "Oh, so..." The program might restart. What's that analogous to? That's analogous to somebody else coming in and jumping in and taking over the process. Well, they might not actually know what's going on, and so they need a long term memory so that they can load it and they can do it quickly. And then once it's... And it gets replicated. So here's another area of scalability. In other words, the equivalent of cashing is like you have these written procedures and they get copied down into people's brains.  |
|  | And so what needs to happen is when these things get changed, you need to push them to people's brains or people need to check in. That's really where the scalability analogy comes in so that you need to transfer it to their first short term then long term memory, and this is a process called sinking. Now, sinking is another issue, which is at some point you have to have an actual source of truth. You can't just have some kind of false source of truth. So what happens when you have one person that changes one thing and somebody else who changes another thing? How do you reconcile those differences? You need to know what sequence and what needs to go on today. Again, what's the analogy here? When you've got these procedures, in somebody's head, they might actually start behaviorally doing something different that doesn't match what's actually documented and written down.  |
|  | And as a result of that, it introduces this disconnect between what's actually documented and how it's actually being executed. So in that particular case, which... In that particular case what you need to do... And on top of that, you might actually have management making changes to these and thus needing to... And thus creating multiple levels of difference where you can't just update them. So what you need to do is you need to take a look at these and compare them. And by comparing them, essentially what you do is you work for the differences, you figure out which difference resulted from changes by whom, and then you interview those changes and you make sure that the changes still create a coherent whole, which is basically the process that happens in software development in a code review process. Or not a code review process, but in a conflict merge.  |
|  | And from a software standpoint, one of the ways that you do this is you, A, either assign something as the source of truth and you force people to do that, or you've got some other process of reconciliation and sinking and the less real time the sinking, the greater the likelihood of changes. And then what happens when you've got multiple people trying to change the same process and they change it both different ways? Now you have a conundrum that requires human intervention because you need to actually look at how they're doing it differently specifically and be able to reconcile those.  |
| Speaker 2: | Okay, so taking this a bit further, you also have to understand that these things are divided and categorized in different ways. In other words, there's things all the way in the very basic granular structure which are called statements and then blocks and then functions and classes and modules and libraries and applications and even application suites. In other words, this whole design process is extremely fractal and in relationships with between statements and logical, coherent grouping are actually ones that apply in how these particular module \[inaudible\] responsibility that you're doing X, Y, or Z but if you \[inaudible\] outside of that, the last thing you want to create is... You create a Swiss army knife, but if you create a Swiss army knife which at its core is this container that holds all of these isolated, separate tools.  |
|  | And if you have a tool that grows separate and if it evolves into this Swiss army knife \[inaudible\] you have this convoluted mess where it's like maybe it kind of works because there's some things that just need to be done, but it becomes a series of tasks, which is a whole other form of programming which called is scripting. In other words, there's these isolated things that need to be done, isolated tasks and just go do them and they need to be done towards the environment, but they're not really... They're critical for that. They're not actually part of the... They fall typically under a different set of rules they can be shorter and linear base \[inaudible\].  |
|  | So along with that, you have to understand, \[inaudible\] which are these tasks. These are essentially the scripts of the batch processes that need to be run, that support everything else that's going on. But then we also have the whole itself, \[inaudible\] itself and how those things \[inaudible\]. So there is another part of development which is the code review process, which means that you always \[inaudible\]. Then you also have feedback \[inaudible\] so that's one aspect of it. Then the more you can verify that these things are actually same, \[inaudible\] actually reported that everything's reported that needs to be reasonably reported.  |
|  | There are some additional pieces that I think I was going to tie into that. Getting this, so I'm going to give me a moment and I'm going to have to think about it a little bit and see what else to come up with. Oh, here it is. Something else that's really interesting is that \[inaudible\] what it means software is you really a set of instructions organized in a logical, coherent manner to interact with the outside world through control and defined means with an exchange of communication, with an exchange of stories of information. So people from the outside who are providing information providing \[inaudible\] and there's a specific set of instructions of how to \[inaudible\]. And \[inaudible\] something useful, there's a whole black box on the outside of what appears to be happening. But there's actually so many layers \[inaudible\] what actually is happening, and this is not a dissimilar analogy.  |
|  | One of the challenges that you face along with that is that ultimately what you want is a high level \[inaudible\] design process because you lose context for it. Or you have something that is actually designed in a different context and environment and conceptually they say it's a plug in away, but it's actually not. And so you end up having to it shoehorn it and you basically introduce, if you don't have control over changing \[inaudible\] analogous to say a vendor or something, a particular vendor you're working with, if you don't have the ability to change how they're offering, you end up... The biology example is whether... Remind me of the rule of three. I'll get back to that. Biologically example is you form a callus or something around that and \[inaudible\].  |
|  | But what you need to do is be able to find a way to isolate that in a way that you can manage the complexity and again, isolate it. You want to isolate... Whatever you can, you want to isolate. Isolate it as much as possible. Isolate, it means reducing, keeping it a very low life, reducing the number of impacts that impacts the amount and reducing how much impacts of the organization. And then there's this whole concept of rule of three, which is... Well actually there's also this concept of refactoring, which what does refactoring mean? Well, if you look at the total cost of ownership on a software project, its industry standards say it's 10 to 25%, the initial \[inaudible\]. Well, why is that? It's because \[inaudible\] actually, apparently \[inaudible\] it's a very, very dynamic space \[inaudible\] constantly being applied \[inaudible\] of innovations.  |
|  | It was 10 to 20 years ago, what we were talking about was 15 years ago, we were talking about maybe 10 years ago... Where was it, 15 years ago? What we were talking about was web 2.0, which went from a static document based web to a interactive web. And now we're talking about web 3.0, which is a decentralized software. And so that software is by nature very dynamic. And as a result of that, you have to invest in maintenance or you're going to completely lose the software project and the cost of maintenance costs anywhere from 10 to 25% every year. Well, how does this actually translate? If you really want to be \[inaudible\] and you really want integrate processes effectively, you have to allow room to... Like, yes, it will speed it up in your process, but you also have to allow room to be able to go back and revisit it and edit it and make changes and revamp it.  |
|  | And more than just tweaks and edits, there are times when you will have to restructure entire parts of it so that you can tweak that. Why is that? Because business is... Again, you kind of know what type of business you're in. But the more static to your business, the less you have to do that. The more dynamic your business and the more vulnerable you are to using parts outside of it, then the more important this is. Now, there's another tool set in programming called refactoring. What is refactoring? Well, refactoring basically is... Let's actually start with this rule of three. What's the rule three? The rule of three says that before you generalize something, in other words \[inaudible\] should generally implement it about three times. Otherwise, what you'll end up doing is you'll create this monster that appears to be very automated, elegant, it strictly deals with what you idealize what happened, but it's not actually grounded in reality. So you've over complicated it and because you don't really know what this is you want \[inaudible\] but doesn't actually work.  |
|  | This is very common with people who are trying to fill out that business process where they've actually built out the business. You want to build a high margin business on the front end so that you can actually have the room and space to build out the process. But you want to do this repeatedly before and allow yourself the space to be able to process this. And by the way, there's different skill sets to innovating through this first number of iterations and finding the common patterns and systematizing it to keeping that machine going and reusing. So one of the things you want to do is you want to look \[inaudible\] where you say, "Hey, this sounds a lot like this thing that we're doing over here." Is this basically the same thing and maybe these can actually be consolidated \[inaudible\] maybe they can't. If they can't be consolidated in the same process, one of the tools that you use is \[inaudible\].  |
|  | So in other words, basically what you have is a... Hey, when you update this, make sure that you update this over here as well. And the other place says, "Oh by the way, update this. Go back to this other place." By doing that, you can make sure that things are very similar and work very similarly but slightly differently, you'll have a confusion of trying to create something that works for both substantially different but substantially similar types of procedures. Make sure that if you make changes to one \[inaudible\]. Now there's also these questions about what makes a good development environment. And one of the things that makes a good development environment is that it makes it really easy if you find connections and find the things that you're looking for. And in any type of situation like this, you minimize the amount of time that you actually spend looking for things and you make it as easy as possible to actually find what you're looking for \[inaudible\] things. One is \[inaudible\] system works for innovation.  |
|  | Second thing \[inaudible\] might not be completed \[inaudible\] that you really, really want to nail down. So there's another very common design pattern that you see, which is a tree structure. And one of the reasons why tree structures are helpful and relevant is that they represent the practical nature of things, which really is not unlike an orchard. It's not unlike many of the things that you might have. I don't really know how this actually goes into an organization, but one of the things that does is... Well, one of the things that does is it really gives you a way to... It verses a list where a list is a linear set of things. It does allow you to easily segment. Another way of representing a tree structure \[inaudible\] what this means is that you can... Like if you imagine little circles with he leaves in it and bigger circles for the branches and bigger circles for \[inaudible\] to subset any number of related issues and related pieces based on \[inaudible\].  |
|  | For example, you might say there's this one piece here that is related to... Here's this marketing task. I want to see what might be impacted by changes to the task. And so you look at things that are closely somewhat related to it and less closely, less closely, less closely. And you \[inaudible\] you're able to identify where \[inaudible\] there's a good chance that there's good practical benefits. It's not immediately apparent, but it's something worth considering. One of the traits of software, one of the interesting things about software is that small changes going to have big impacts. So for example, if you take a software system and you rewrite it completely from scratch, often means that to the project, and the reason is that there are small pieces of detail that have significant impact and ramifications. So there may have been this one scenario, simple scenarios where something went wildly sideways.  |
|  | The developer made a series of small fixes to prevent that. The problem with completely redoing things is that there are certain nuances in that. So you may look at it and \[inaudible\] you may underestimate the actual importance of it \[inaudible\] mitigate this by \[inaudible\] you understand perhaps not in the... Maybe it's not important for the people who are actually going through that, but for people who are considering to change it, they need to consider why \[inaudible\] way that they are \[inaudible\]. Bug fixes are part of the process and by bug fixes, I don't just mean... Correct \[inaudible\]. It's different ways to fix problems, \[inaudible\] systematically. Now there's this final big piece which is probably one of the greatest skills \[inaudible\] proposition, which is managing \[inaudible\].  |
|  | And again, different types of developers will focus on different types of things. So if you have a certain type of... You have to understand that certain types of software features have very low level of need for accuracy. So if you have any software where accuracy or performance, where timeliness, accuracy are not a major issue, then quality of \[inaudible\] actually be more important. But when you have situations where... When you have situations where accuracy actually does matter substantially, and that's where attention and care for detail are more important. So again, very pragmatically, when it comes to building out these processes, put the detail oriented in place, the things that require precision and allow other people to... Allow other people to do \[inaudible\]. One of the things that... So with that and everything there is this drive for pragmatic benefit, pragmatic \[inaudible\] lot of people, room for error, usually error on one of two sides.  |
|  | One, they try to do prematurely and as a result they build a machine that doesn't actually have any power \[inaudible\] there's other people who do it complete. So it's like the higher \[inaudible\] so well you can \[inaudible\] engine is a system. So if you system \[inaudible\] years and of you have a low amount of momentum \[inaudible\] a vehicle engineer high gear \[inaudible\] lightweight system if \[inaudible\] heavily and \[inaudible\] you're going quickly or you're going to max out your \[inaudible\]. So how do you do that? I think this is always a understanding in progress. This supposed to serve you and make your life easier, not harder. So start with the pieces that are most difficult or what can most easily be offloaded or delegated.  |
|  | So that's that. And then there's this process of, how do you actually break this down? I think one of the easiest ways to do this is your process of tactical delegation, which means there's any number of ways you can do this. So ultimately what you want to do is you need to have some kind of recorded storage in some format or another. It can be written, it can be spoken, it can be video, and it is a trade-off between speed of changing it, and that giving small parts of it versus ease of doing it the first time. Usually it's more work to do it the first time in a way that allows you to easily update the future. So it's a trade off. But then there's also this secondary issue that different people have different preferred means of communication.  |
|  | So some people prefer \[inaudible\] on the fly and some people prefer recorded... The ability to take things through. So you might have wide spoken. And so simply what you can do there if somebody has wide spoken, there's a few things you can do. Easiest thing is just to record it and have it transcribed with something like Otter. You might have something \[inaudible\] written which may come down to a chat or text message or email exchange. Email may end up being a heavyweight and then you can capture it and restructuring it and reformatting it \[inaudible\]. Or you may have somebody that prefers live demonstrations. Again, video can be a great way of doing this for feedback, \[inaudible\] yourself can be a way of doing \[inaudible\]. Ultimately what you're looking for is you want to translate it from a live environment into a recorded environment so it can get translated back into a live environment.  |
|  | So keeping in mind there's these three primary modes of communication and learning and modeling it appropriately. And you'll find that in different types of roles that you'll have proclivities in one direction or the other based \[inaudible\]. So for example, if you are in some form of manufacturing things for your Etsy shop, those types of people may be more inclined to learn by watching any collections and by doing, and so you build your training processes on that and you may actually want to have some kind of... Here's a simple example. You may actually want to have a physical board that has pictures of the latest task with possibly a QR code that allows you to pull up specific video for that particular \[inaudible\]. Or you may actually have a print-out, a series of \[inaudible\]. People who are... Some people who... Again, some people may prefer flow charts, more of a step by step instructions of this, this, this, and this. And then this is my personal preference because of the ease, simplicity of the tool set. Simply allow yourself instructions, \[inaudible\] categories that you need done \[inaudible\] steps.  |
|  | Yeah, it's very easy. \[inaudible\]. Here's another really interesting correlation, low level versus high level of languages because I think low level languages can be roughly equivalent to unskilled labor, which means that you can... I mean, theoretically you can take anything and you can break it down in a unskilled level, but if you were to write website in assembly language, it would be so ridiculously complicated, but it probably would be \[inaudible\]. Now that's an extreme, but with higher level languages, higher levels of abstraction allow means that there is some kind of pre understood ideas, things like that, that allow you to get things done.  |
|  | So what you want do is you want to tailor the instructions that you have with the level of knowledge that you expect us to have. So by and large, your lower level tasks will include a much higher level of detail because people \[inaudible\] context and less knowledge. On the other hand, your responsibilities for your procedures for a marketing director for example, will be higher level and things that you might actually put in, any information about or here are the things that need to be done but \[inaudible\] requires part of this. Or again, just understanding that high level languages allow you to say a lot in \[inaudible\] words. The more skilled your team member that you're working with, the more you'll be able to do that. So just tailor it appropriately.  |
|  | Again, there's two things that you're looking to do. One is to remove unpredictability as people are \[inaudible\] and the other thing is to be able to let them go on vacation and have somebody else cover for them. So if instructions are \[inaudible\] more than just the basic ongoing responsibilities, but even that can be... So those types of responsibilities, if they reasonably can be \[inaudible\] outside the role, you might use more specific language work and more reverse language work versus high level conversations.  |

