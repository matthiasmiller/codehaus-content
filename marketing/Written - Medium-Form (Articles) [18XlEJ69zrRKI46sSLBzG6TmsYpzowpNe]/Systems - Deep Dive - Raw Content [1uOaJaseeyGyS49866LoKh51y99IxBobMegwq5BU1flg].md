# **Systems \- Deep Dive**

●      [https://otter.ai/u/krWfPEGcn-SLIdw1K6pQtgwS4nc?f=home](https://otter.ai/u/krWfPEGcn-SLIdw1K6pQtgwS4nc?f=home)

●  	System

●      **Levels of abstraction**

Okay, so what did it take some time because Ricky asked me a question about why he asked the question, why is can a small website not keep up with volume of streaming video, but YouTube can't. And why is it so expensive that it would take millions of dollars to scale up? And well, well, while I don't have the exact, full, in depth reason in a way that I think I can articulate.

# **Pair Programming**

TODO

here's another interesting way to look at it. If you look at the evolution of software, and the evolution of language, then. Then you have the postcards and then the assembly language and it's like, well, let's do complicated. Let's make shorthand for that. And then that ultimately everything was predominantly linear.

And so somebody's said, Okay, well, instead of like, let's not make this completely linear, let's say, We're gonna let you say go to what I mean. Maybe this is from the beginning, go to Step four, and repeat. Okay, well, that's good. That's really complicated. Like, like, how do I keep that in my head? And so then it's like okay, well, we're gonna put names to this go to the part that's named you know, you know, show error on the screen and then the let's go on the you know, let's let's and then when it's done then it can go it can tactic does to go to somewhere else. And so we don't actually had to know the actual location, we can just refer to it by name, and then it's really easy. And then finally said, Okay, well, this is good, but we have to pass information back and forth. And so, in order to do that, we need to have something called parameters. In other words, there's certain types of input and certain types of output that these these things can have and and how do we, how do we define those? How do those get passed, passed around? And then we started creating a convention for that. And then they said, Well, it's actually not quite that simple because now you have two versions that are worked together and, and how do those things tie together? Well, you have something called the class or the class to share some information. And, and oh, by the way, there are some design patterns that are really important when you're working with classes which is which is, you know, you can have I mean, for example, well, first of all, there are some design patterns, resources that are really important.

For example, there are some contracts that you're going to keep. In other words, I'm only going to ask you to do this under this, these situations, I'm going to only only going to tell you a certain subset of things and then and then when you're done like you promised that the world will be in this kind of a state when you're done. And the same with classes like this class is responsible for a conceptual conceptual part of the part of the process. Now, this this concept has been in it in the you know, in software development from for a very long time, even before was called this, where it's like, well, what what is the class what classes is often represents some kind of thing. So sometimes it's an abstract thing and sometimes it's a more tangible thing. So for example, your you want to start working with a file on disk, there's a series of operations that need to happen in order for you to do that you need to let the operating system know that you want to open the file you want to tell it what to do as a file doesn't exist and you need to know what what you're planning on doing doing with the file so you don't accidentally do the wrong thing with it. So you can keep yourself from shooting yourself in the foot and then once you do that, then you need to tell what part of the file you want to go to. And then once you're in the right part of the file, then you need to know you need to decide what you're going to either read or what you're going to write or if you do both and then you need to tell it that okay, I'm done doing whatever I need to do the final week

I'm done with that I'm not going to be doing anything with it and then it closes don't have access to it and and that gives the operating system a chance to go write these things to death so that your information doesn't get lost and and it helps your your operating system manage resources because now because even though it's a small amount it takes there's some bandwidth for it to to be able to keep track of your file and the changes that you're making. And then once you've got that then what's the next piece well, okay, so, so then these are the types of things that you can you can use you can make it read only you can you can look at certain physical piece of information you can query it find out when it was last modified and these are all parts of accessing files, well, oh, look at all these functions that do the same thing. And they're all interconnected and interrelated. Well, this is actually, you know, conceptually. This is a this is a class. And so we're going to create a class called a file that has all of these functions that it can have. Now, how does this actually relate with business? Well, first of all, there's all kinds of interesting things that the that the that are going on under the hood when you're working with the file, but you don't actually need to know when you're working with a file. Like you don't really need to know this information, but it's happening under the hood. So what does the class do? A class helps to hide that information from you so that when you ultimately when you want to work with the firewall, you need to know you need to know the file name, you need to know some things about what you're gonna be doing. And then you need to perform the actual actions. And so here's one of the lessons that we extract from from business is that sometimes there's groups of activities that you're doing together that logically belong to each other. And, and, and you want them to be to be interconnected with each other. And because of that, you can well, and so you can put them all under one roof and and when somebody wants to go and the way that you manage complexity is you look at the points of communication so how do you get at the point of intimate communication? Well, you only share the information that needs to be shared, you try to reduce the number of people that it needs to be shared with. And when you do that, you isolate and eliminate complexity. So you might have a sales department that's really complicated. We have a marketing department that's extremely complicated. And there's all these folks talking to each other. But what you do is you have you haven't you have parts within any part of the business talks as much as it needs to with with other people, but when you try to limit it to a single point of contact, you dramatically reduce reduce complexity. What does this also mean? Well, systems and processes are much more than just step by step instructions. It's about finding the natural order and the natural structure that is that is emerging from within the organization. So now there are some patterns that we have. Well, there's, there's there's some other issues too, which is it's centered around scalability like how do you how do you skill software? Well, at some point, you need to have a you need to have one source of truth for your information like you can't have you can't have to two people out there with with the same name and same social security number and different phone numbers because, well, then what what are they like which number is correct? And so let's say that you have a massive amount of storage and massive amount of information that you're dealing with and you need to synchronize this information across multiple people that are that are wanting to use it how? Well one of the ways that you do is one of the things you can do is you say okay, well, it's perfectly appropriate, appropriate to have somewhat stale information. So sometimes on a news website, just the act of saying that somebody is going to have one second still news, or that somebody's watching a streaming video that's one or two seconds delayed, introduces enough delay and enough of a capacity that it allows the to steer the burden and and speed it up so in other words,

so why, why is this? When you have only one source of information, that's the source of truth, then you have two dozen people that are going to this one person, and this one person gets overloaded because they only have so much bandwidth. So when the same people then you say, Well, no, that doesn't make sense. So so in the in the case of software, instead of just having one computer to go to, we're gonna have that one computer still gonna be the source of truth, but it's going to share its information with six computers. And each of those six computers will have a copy of the information that's been delayed. And so every second it's refreshing it to get the to get the latest to get the latest information. And and then and then instead of, you know 15 People going to, to 18 people to the first person you now have whatever the numbers are you got you know just a handful of people going to each one so suddenly you've multiplied your capacity because you've introduced some kind of a delay. Now, what does this mean in business? Well in business, sometimes you may have something that is the source of truth like a city or county. And, you know, maybe this is less true in a digital context. But it may be true in a you know, from a procedural standpoint, so there is a master procedure list that gets handed down to from department to department and, and because there's a delay then we're able to allow the

then then people can go ahead and instead of asking just one person and bombarding one person with all of these questions, they're actually able to go to multiple people and there's multiple sources of information for this now what's the problem with this in any kind of software environment? Well, one of the problems is, is that what happens when you have three copies of this information and, and the source of truth changes so, so three computers have memorized my contact information and it changed the actual contact information? How do they know to update? Well, there's a few ways that they can do this one, you can say, well, we just do this automatically every second. So if you catch it within a second, then you're gonna get stale information. What does this mean in an organization? You could, it may just mean that it takes time to roll out changes and whenever these changes get rolled out, and people get notified, and if you're okay with a delay, you're fine. Now what's another way to do it? Well, you can have a you could have a quick check in that basically says, Hey, I'm here with this information, is it is it still up to date? And if it was, then you then you go, or good? Or you could say, Well, every time we get this information, we're gonna go see if it's is this out of date and if it is, then we're gonna go fetch it ourselves and replace it. So there's, there's a number of ways that you could actually deal with this issue. Or you can have, you know, whatever, when, or you can have this proactive or you can have a proactive state where, where this is when when something is out of date, then it gets pushed down to let it get gets, that actually gets pushed out. Alright, you're gonna have a hybrid approach, which is like, okay, there's a new policy. Now we're going to go to, we're gonna go yank that policy out of the binder and whenever you need a new one, you're gonna come back and you're gonna find a find a new one for us. And so that's how you deal with issues of scalability and how to how to prevent the duplication of information. Now, what you really want to avoid is you what you want. What you really want to avoid is you want to avoid duplication of mystery. You want to prevent the spread of misinformation. And the way that you prevent the spread of misinformation is that having only one source of true information. Now, what what are some other you know, what are some other parallels and equivalents? Well, another federal equivalent is there's something in suffering. There's something in the hardware side, which is short term memory, long term memory Well, what happens when you plug unplug your computer? Well, ideally, all that happens is up against goes down into anything that was open your programs and you know, unless you're like Mac and you Well, I mean, maybe Mac doesn't even do this, but it turned himself down. And as a result of that, you lose all the information that he had open in your progress, but the files on your hard drive are safe. Now. There's some some very specific timing situations where, especially in olden days, if you have power at the wrong time, then you might have a partially written file and you wouldn't and file wouldn't be valid if you might actually lose information on disk. But by and large, we solved that problem. And by the way, we now have batteries, which means that the loss of power is very unlikely, but nonetheless, computer has has a concept of short term memory versus long term memory. Well, what's the benefit of short term? Memory? The benefit of short term memory is that it's super super fast. In other words, like, I mean, if you're dealing with, you know, one of the fastest things, well, you know, as an example, when you have software you might have a million lines. The project that we worked on had upwards of a million lines of code. And, and because of the way this this stuff is interconnected, it was ended up processing. I don't know exact numbers, but maybe five or 10 million lines of code because of how again, how how those technical pieces of information happened through the reading this much information and enough to be a bottleneck, especially at the point that you had, that you had a valid you know, whatever your your CPU, your processor was fast enough, and then the slowdown would become reading all this information on this. Well, what's what's it analogous to? RAM is analogous to this is analogous to your short term memory and and written procedures are analogous to long term memory. So So why do you need them? Well, short term memory is good, because it's really fast that you can remember but the problem is that there can be blessing in your short term memory. And so that's when you need long term memory. Or you might close down the program and and somebody else might come up and, and show like log in and be like, Oh, so you know, the program might restart. What's that analogous to this? That's analogous to somebody else coming in and jumping into here in the process? Well, they might not actually know what's going on but so they need a long term memory so that they can load it into they can do it quickly. And then once it's, once it's, it's, it's it's like it gets replicated. So here's another theory of scalability. In other words, like

the equivalent of caching is like, you have these, you have these written procedures and they get copied down into people's brains. And so what needs to happen is when these things get changed, you need to push them to people's brains, or people need to check in and that's really where the scalability analogy comes in. So that you need to transfer it to their their for short term, their long term memory. And this is called you know, this is a process called syncing. Now, no thinking is another issue, which is, at some point, you have to have an actual source of truth, like you can't just have some kind of false wish, which is what happens when you have one person that changes one thing and somebody else who changes another thing, how you reconcile those differences you need to know What's the content? What needs this was what needs to go in today? Again, what's the analogy here when you've got when you've got these procedures in, in somebody's head, they might actually start behaviorally doing something different that doesn't match what's actually documented and written down. And as a result of that, it introduces this disconnect between what's actually documented and how it's actually

being executed. So, in that particular case,

with that particular case, what you need to do and on top of that, might actually have management making changes to these and thus meeting to creating multiple levels of difference where you can't just update so what you need to do is you need to take a look at and compare them. And by comparing them essentially what you do is you look for the differences. You figure out which difference resulted from changes by whom, and then you interleave those changes, and you make sure that the changes still create a coherent whole, which is basically the process that happens when talking about the process. We're not a code review process but in a conflict merge from a software standpoint, one of the ways that you do this is you

either assign something as the source of truth,and you force people to do that, or you've got some of the processes of reconciliation and thinking and then the less real time, the thinking the greater the likelihood of changes. And then what happens when you've got multiple people trying to change the same process. And if you do both different ways, now you have a conundrum that requires human intervention because you need to actually look at how they're doing it differently specifically, and be able to reconcile those Okay. So, taking this a bit further you also have to understand that these things are divided in categorized in different ways. In other words, there's things all the way in the very basic granular structure which are called statements and then blocks and then functions and classes and modules and libraries and applications and even application suites. In other words, this whole design process is extremely fractal and Yeah relationships with between statements Groups. There's their responsibility if you're doing XY or z, if you very similar outside of that. The last thing you want to create is if you create a Swiss army knife, but if you create a dummy knife which should be at the core is this container that holds all of these isolated separate tools and if you have a tool that grows separately, and you if it evolves into it into a Swiss Army Knife without proper categorization, preferably a unifier then you just have this convoluted mess where it's like maybe it kind of works but there are some things that just need to be done. But there's, there's not always it becomes a series of tasks, which is a whole other form of programming. It's called scripting. In other words, there's these isolated things that need to be done isolated tasks. And just go do them. And we can support the environment, but they're not really, you know, they're critical for the for that they're not actually part of the they fall under, typically under kind of a different set of some rules. They can be shorter in the linear base doesn't always necessarily tie elegantly to emerging coal. So along with that, Kevin, one of the things you see with we were going to present is that procedures which are this one on pass, these are the essentially the scripts, the batch processes, that needs to be run, that supported progress that's going on, but then we also have the whole itself itself and how those actually functions. So there is another part of development which is, is the code review process, which means that you always have a second device, looking everything and trying to see because essentially what happens is there's balance transfer happening both directions. First of all, you have some risk. But then you also have feedback on investing and have something with a fresh set of eyes. So that's one aspect of it, but it is something else that happens is an actual UA which, again, we're not stringent on this, but I wanted you to be able to have what I didn't execute at least once and then the more you can verify that these things are actually saying it actually gets recorded that everything's recorded. That needs to be reasonably reported. There are some additional pieces that I think it was going to tie into that. Getting is going to give me a moment to think about a little bit and see what else I came up with. Here is something interesting is usually what a piece of software is, it really comes down to a set of instructions organized in a logical coherent manner to interact with the outside world. Control the defined means with with an exchange of communication with an exchange and storage of information. So, people from the outside who are providing information, providing something there is a specific set of instructions of how to get that information or that information something useful there's a small black box of outside of what appears to be happening but there's actually so many layers beneath what actually is happening. And, you know, this is not not a dissimilar analogy. One of the challenges we face along with that is that ultimately what you want is a high level level. system the greater picture it's because of missteps. Decisions decision design process because you lose context. Or you have something that is actually designed in a different context and environment and conceptually, they say it's applicable. But it's actually not a result, you end up having to shoehorn it in you basically, introduce, you don't have control over changing. So that is analogous to, say a vendor or something particular vendor you're working with and you don't have the ability to change how they operate. You end up you know, the biology. Example is another way to remind me of the rule of three. I'll get back to that logical example if you form a callus or something around that. And you just let yourself in, but it's interesting, but sometimes you actually somebody processes me but what you need to do is be able to find a bit of that in a way that you can manage the complexity and again, isolate. You want to isolate whenever you can't isolate, isolate it as much as possible. Isolating, it means reducing, keeping it a very local impacts. See how much and there's this whole concept of the rule of three which is, well actually, there's also this concept of refactoring, which What does refactoring mean? Well, if you look at the total cost of ownership on a software project, its industry standards, they tend to represent the initial why is that? It's because it's actually apparently a static transaction is very, very dynamic space. being applied the speed of innovation it was 10 years ago, we're talking about was perfecting yourself we're talking about. or 15 years ago, when we were talking about was what to window which went from a static document based web to a you know, interactive web And now and now we're talking about what what we put out which is the centralized software. So suffers by, by nature, very dynamic, and as a result of that you have to invest in maintenance, or you're going to or you're going to lose a project and the cost of maintenance costs represent every year. Well, what does this actually how does this actually translate? If you really want to be really want to integrate processes effectively, you have to allow room to look yes, it will speed up your process. But you also have to allow to be able to go back and revisit it and edit it and make changes and revamp it and more than just tweaks and edits are times when you will have to restructure entire parts of it so that you can do so that you're gonna continue to adapt. Why is that because business is what type of business but the more static your business, the less you have to do that the more kinetic your business and the more vulnerable you are to moving parts outside of it. Then the more the more important. This is another another tool set in programming called refactoring. refactoring. Well, refactoring basically is let's actually start with three, three, the rule of three says that before you before you genericized something we should generally implemented about. Doing this you'll create this very quickly deals with what you idealize would happen but it's not actually grounded in reality so complicated. Because you don't really know what this is more. You can be useful it doesn't actually work. This is very common with people who are trying to build out a business process when they've actually built out the business. You want to build a high margin business on the front end. So you can actually have the room and space to build the process, because you want to do this repeatedly before and allow yourself the space to figure this and by the way, there's different skill sets. To innovating to this first number of iterations and finding the common patterns and systematizing it to keeping that machine going. And we're using so. So one of the things you want to do is say hey, this sounds a lot like this thing that we're doing over here. Like is this basically the same thing can be consolidated and they can't be consolidated the same process one of the process, really in other words, basically what you have when you did this, to make sure that you repeat this over here as well, and the other places oh, by the way, it could be this place. By doing that, you can make sure that things that are very similar and we're pretty similar, but slightly differently. Confusion of trying to create something that works for both substantially different but substantially similar types of procedures, make sure that we can make changes to one you think, the application. Now, there's also these questions about what makes a good development environment and what are the things that makes your development environment that makes it really easy to find connections and find the things that you're looking for. And in any, any type of situation like minimize the amount of time that actually spent looking for things. Make it as easy as possible actually. A few things one is a good system for organization. Insert search for your seats and we're not going to wait and really, really want to know about you prize So there's another very common design pattern that you see which is a tree structure. One of the reasons why choose structures are helpful and relevant is that they represent the fractal nature of things. Which really is not unlike an org chart. It's not unlike many of the things that you might have. I don't really know how this actually plays into an organization. But one of the things that does is well, one of the things that it does is it really gives you a way to, to versus a list we're list is a linear set of things. It does allow you to easily segment you know, another way of representing the tree structure, so to speak, it does mean that you can, like if you imagine, wall surfaces all the leaves and if your circles subset any number of related issue and related pieces based on based on the level of specificity, for example, you might say, there's this one here, that is related to like, here's his script. I want to see where, what might be impacted by changes to this task. And so, you look at things that are closely somewhat related to the less closely less closely less for free and go expanding after concentric circles. We're able to identify where potential leads, there's a good chance to serve some kind of practical method. It's not immediately apparent, but it's something worth considering. it's if you take a software system and rewrite it completely from scratch, it's often means depth to the project. And the reason is that there are small pieces of detail that have significant impact and ramifications. So, there may have been this one scenario sample of scenarios where something went sideways a series of small fixes to prevent that problem with doing things is that there are certain nuances in in that so because it appears to be in detail, you may underestimate the action together. mitigate that as much as possible to mitigate this by mutations. Document. Fixing by doing things a certain way, and then being a fantastic array of data. Managing versus waiting, simply don't understand perhaps not in the Maybe it's not important for the people who are actually going through that but they need to consider why they bug fixes are part of the process, and bug fixes, I don't just mean intelligence mean correct ways to fix problems with systematically. So now there's this there's this final piece, which is probably one of the greatest skills that comes from position which is managing work maximum. And, again, different different developers will focus on different things. So if you have a certain type of you have to understand that certain types of software features, temporary levels of the printer cracy. If you have the software that's where accuracy or performance or timeliness accuracy are not a major issue, then quality of rebate actually be more important, but when you have situations where we have situations where accuracy actually does matter substantially. That's where attention and care for detail are more important. So again, very pragmatically when it comes to building out these processes in detail for you, to place the things that require precision and allow other people to allow other people to do the things so with that, in everything there is this drive for pragmatic pragmatic benefit was actually usually one thing, surely, as a result, we build a machine that doesn't actually have to worry. There's other people who do that. So it's like hierarchy. So what's your engine is a system so if you if you systems are like yours, and if you have a low amount of momentum in a vehicle, hear I hear all the distractions, like we're just going to give one away and you're going to look here and you're going quickly, or you're going to max out Europeans and that's the scenario worst case scenario. You really want to start later. So how do you do that? I think it's always a work in progress. This is supposed to serve you and make your life easier, not harder to start with the pieces that are most difficult or that person can most easily be offloaded or delegated. So that's that and then, then there's this process of how do you actually break this down? I think one of the easiest ways to do this sort of process of tactical delegation, which means any number of ways you can do this. So ultimately, what you want to do is you need to have you need to have some kind of recorded storage in some format or another, it can be taxed, can be written or it can be spoken for TV video. And the it is a trade off between speed of changing Egypt changing it and updating small parts of it, versus Ease of Doing it the first time. Usually it's more work to get it to the first time in a way that allows you to easily get the feature. So it's a trade off. But then there's also this secondary issue that different people have different preferred means of communication. So some people prefer to live on the fly and some people prefer recorded so you might have live spoken and so simply what you would you can do there if somebody has like spoke smoking, there's a few things you can do. Easiest thing is just to record it and have it transcribed using something like otter. You might have something to utilize written, which may come down to have a chat or text message or email, exchange. You know, may end up being heavyweight and then using that kashrut and restructuring it and reformat it or you may have some leakage occurs live demonstrations. Again, video can be a great way of doing this for feedback, watching them do it practices or doing it yourself can be amazing. What you're looking for, is you want to translate from a live environment into a recorded environment, that it can get translated back into a live environment accurately. So keeping in mind that there's these three primary modes of communication, learning and modeling appropriately, and you'll find that in different types of roles that you'll have proclivities in one direction or the other based on first so for example, if you are in some form of manufacturing things for your Etsy shop, those types of people may be more inclined to learn by watching collections. And by doing so, you've built your training process. And you may actually want to have some kind of mean, here's a simple example. You may actually want to have a physical board that has pictures of the tasks with a QR code that allows you to pull in specific details for that particular class. Or you may actually have a print out a series of books that's once you freak. out people who are some people who again this this, some people may prefer flowcharts more of a step by step instructions of what to do this, this, this and this. And then, you know, this is my personal preference because of the ease and simplicity of the tool set. Simply allowing yourself to complete the inspection. Putting in big categories of steps. It's very easy to read into, style Here's another really interesting correlation when you consider low level versus measurable languages. Because I think low level languages can be roughly equivalent to unskilled labor, which means that you can I mean, theoretically you can take anything and you can break it down in a unskilled level. But if you were to write let's say in assembly language, it would be surgery ridiculously complicated, but it will prove to be useless. Now that's extreme, but with higher level languages, higher level levels of abstraction, a lot means that there is some kinds of free understood ideas like that, that allow you to get things done. So what you want to do is you want to tailor the instructions that you have or the level of knowledge that you expect to have so. By and large, your lower level tasks will include a much higher level of detail because yet people will text you. The other responsibilities for your procedures for a marketing director, for example, will be higher level, things that you might actually put in information about or hear the things that need to be done. Specifically, by as part of this, we're just understanding that, you know, high level languages allow you to say a lot of words or skill your team member that you're listening with more you'll be able to do that. So just tailored appropriately. Again, there's two things that you're looking to do. One is to unpredictability because people are and the other thing is to be able to let them go on vacation and somebody else cover for them for people. So instructions are certainly fighting. Argument, vacation you don't really have more than just the basic are going to respond. So those types of responsibilities, if they reasonably can be outside their role, and listen to us more specific language work, and more perversely to work versus high level conversations

# **System Optimization**

●      [https://otter.ai/u/xdaKpaxySCQp631H2NnKZUEZNB4?f=home](https://otter.ai/u/xdaKpaxySCQp631H2NnKZUEZNB4?f=home)

I had this realization after hearing Stephanie talking about the theory of constraints. And related works, which is there's a process of there's a tree structure process hierarchical process in optimization, which means in software optimization, so, for example, when you go the first step of any kind of optimization issue is find the worst case scenario first of all, and how do you exaggerate the problem? So, in software, it's like, go throw the biggest data set at it or the biggest, you know, fill in the blank where if it's really the resource contention, go constraint, the problematic resources. So have you know, do something that brings it to the surface and then and then the question is, once you have that, then you do the analysis. Now the cool thing is, with software, you have a call stack, which is essentially a hierarchical view of where the bottleneck is. And so what so you start at a high level? View really clear when you say what's taking a long time. But at a high level, you say, how much time is this? What are the big portions of and how long does each big person take? And then you dive down into into those portions. And it could be that what initially appears to take a really long time is actually quite well optimized. It's just takes a long time. And then you look for you may go into going down a different branch, and diagnosing other further process, you might find that in that part of the process, there's a piece of it that takes an inordinate amount of time that is hyper inefficient, and you can fine tune that. And then as a result of that, you get, you know, marginal benefit. Now, the other thing you might discover along the way is that your algorithm is wrong, which means that your fundamental approach is misaligned. So, what are ways that you can eliminate that? Well, there's a few ways that you can do that. One is you can do more things simultaneously. And so you can introduce multi threading, or some kind of multiprocess thing. You can do more of the similar things at the same time. Or you can try to deal with you can try to cache there's more information in memory at a time. You can, you can and sometimes there's a spirit of faster ways of solving problems. Or a you know, sometimes instead of a highly accurate calculation, you can find a way to get an approximation that's actually accurate enough which you want to do. But it's much less expensive to speculate. It's really hard to tell, I guess, here's the question. You know, typically, when you profiled there's there's two pieces of the puzzle one is what percentage of time does this take of the parent task? And what percentage of time does it take your real task? And so if you search everything, based on time will be a real task and very quickly, you start to notice exactly where the bottleneck is. And that's the thing that you want to optimize first. Usually. So there's two steps to this. There's the profiling process, which is basically give me the data in a hierarchical format, sorted in or appropriate way so that we can actually filter these things to the top of the list, and we know how to address it, then there's the question of how do you actually optimize, optimize it? And you know, I don't really know that I've got much more to add to any of this. So the question then becomes, you know, the interesting thing about this is that this is actually the approach that I've used for the time study, which is, let me profile your time. And, and, really the there's two helpful pieces of it first is you actually have a grid or a framework and some level of categorization, some kind of tree structure to outline your time and I think it could actually be productive to convert this from a grid

to a to a tree structure, where on any given task, you can break down deeper, the deeper levels of the tree structure I'm not completely sure how that might work. But there is this profiling data collection. The way profiling works, is really not that dissimilar from the 15 minute time log, which is, you know, sampling. Let's go see what we're doing periodically. And let's just get a sense off of that what I'm doing is a different approach. Which is less accurate, but still accurate enough to get significant wins from. And then there's the the analysis, which is basically Okay, let's sort these things based on their level of impact and there's two resources being measured. There's opportunity cost, and there's actual time spent to the other cost. So we sort of based on those resources, and that's what drives the priorities that would actually optimize.

Yeah, so there you go. There's this really interesting take on business optimization, which can be taught but feels actually pretty instinctive. To me, and I don't know exactly how to quantify it in the example of dealing with dismissal last night, at the Vacation Bible School is a good example where we are creating distinct separate points of communication between different people, and by doing so, eliminating a lot of complexity and chaos. Because we were able to do that. So there you go. interesting observations about the recommendation and business process optimization

# **Systems \- Threading \- Shared Resources**

[https://otter.ai/u/mBJqk3qcHAfmPvEiBLN-cj99-gw?f=home](https://otter.ai/u/mBJqk3qcHAfmPvEiBLN-cj99-gw?f=home)

that's working. All right, here's another angle of this whole thing. multi threading mutexes shared data locks, race conditions, etc. So when you just a few observations that when you've got a lot of people working in the same type of environment and working on the same types of things that they need to coordinate things so that they don't, don't conflict on shared resources. And this can create a constraint because not only does the shared resource create the problem, create a bottleneck, but the actual act of checking for the shared resource makes it a bottleneck. Let me give you a practical example. Let's say that you've got one truck for two guys. It's not just the fact that only one guy can be on the road at a time. It's the fact that each guy has to check to see whether the other guy is using the truck before he can actually use the truck. Now in a digital world, if you're using something like Excel spreadsheets, for example, you have the same type of resource contention is what it's called. You have one person who wants to use the Excel spreadsheet and the other person doesn't now you can just try to open the Excel spreadsheet and that might be good enough but even the, you know, even the fact that you might not be able to open the Excel document creates introduces delay because you know, you're already Planning for Contingencies of what if I'm actually not able to or if it doesn't, completely throws those off sideways, what you're trying to do. mutexes are basically a way just say, okay, here are the parameters around you know, here, here are the parameters. You know, you can simplify this by creating parameters around how often or when you actually do try to access the shared resource. Now, sometimes you can engineer your shared resource in such a way that there's only one person responsible for actually managing and updating the shared resource. And because they have limited bandwidth. There's the it's a simple matter of sequencing in order so for, for example, in the vehicle example that I gave, the equivalent would be to have is to have a dispatcher where they make multiple requests. And whatever whatever form or mechanism that they want to prioritize it by whether it's by first come first serve, or whether it's by other types of prioritization. They can manage access to the shared resource and then ultimately, you know, there's a final final piece of this, which is there's a waiting that necessarily comes when you have a shared resource and so while you might engage with other with other types of sorry, what other types of activities you still The challenge is that, you know, when you when you've got multiple threads, you can very easily just tell them to wait until the shared resources available, but that's from a human perspective. That's horribly inefficient. And so, ultimately what you have to do is do this from a systems perspective. So you've got your notification or something like that that occurs when something becomes available.

Call Waiting hold. These are types of examples of managing asynchronous communication because you've got a shared resource, ie either a person or a phone line. And you can either wait until the resources available or get a call back. I mean, this is I guess along with that, there's synchronous waiting and asynchronous waiting, has in literally, this is called a callback. And when a great example, again is customer service, when are you going to wait, wait, well, actually, there's three types. Three ways to do this. One is I'm going to there's synchronous waiting. There's event driven notifications, and then there's polling polling just means I'm gonna check check, check, check, check until it's done. Now. The problem with that? Well, and along with that, there's also timeout typically with the with any type of waiting, perhaps not with event. Driven but so you have

to let's say that you've got a project that is an email that you send, and you don't get a response. Well, clearly, it's not a logical approach to simply wait until you get a response. So that means that you are either waiting for an event driven or pulling, pulling type of response. With this, there's also the concept of timeout. So let's say that you pull, which means that you periodically check back in and say, Hey, did I get an email? And if not, you might actually ping them and say, Hey, can I have an answer? To my email and you continue this event driven? You simply wait for the response to come back. And in the example of Google, it comes back to you after two days or three days, and you haven't gotten a response. So this guarantees some kind of timeout on the responses to your email messages. The same thing applies to so this is one of the ways that you prevent system failure, or that you protect against it. because the question is, how do you protect against things when they go completely dark? Well, you need contingencies for that. So what happens when.

What happens when somebody is on hold for 10 minutes, and I didn't know they didn't just. stranded you ring them back into the main queue and you prioritize them to the tops of Cubans and it rings again

you talk to somebody who's more likely to be available and says hey answer this call

# **Systems Refactoring**

●  	[https://otter.ai/u/BHGGXshHWLoKr0FgqbMmVGDcGms](https://otter.ai/u/BHGGXshHWLoKr0FgqbMmVGDcGms)

So here's another fascinating take on coding in business because refactoring is natural part of the process. When, when is what makes refactoring be necessary? Well, it's the process of flows to change requirements change direction. It's like it's a continuous self healing process. And it's absolutely critical to continue doing refactoring to make the codebase as flexible and as nimble as and useful as possible. And if you do not refactor that you end up with something that's brittle, which means that they'll try to make a change and all these other things will break because because of it, so what do you do in the process of refactoring? Well, you look for commonalities you look for things that have not been updated in a long time. He looked for things that should be simplified. To tease apart things that have kind of, you know, this thing used to be one thing and it grew into three things and now you split apart the three things. You You You move Part A that has been under this umbrella you remove you know, sometimes you completely redefined how something is done, and you transition out of that way in the old into the new way and, and you delete old code that is no longer necessary because of because of all those changes in requirements. So in business, it's like, it's moving people from one place to another department, it's building out departments, inspiring people, it's rearranging things, it's ultimately rearranging the components of the business to align where the business has grown to splitting apart responsibilities. People were doing too many things at a time. And creating and, and reorganizing and restructuring that and getting the business into a healthier, maintainable place. And if you don't do this, your business is gonna break one way or the other. Business is always code tends to break when you have refactoring. You have to do testing, you have to be careful and you have to take these things piece by piece, but if you don't do it, that will take a different way, which means you're going to hit a some kind of growth plateau. And the same is true in business where if you don't take the time to refactor your business, you don't you don't take time to restructure and reorganize and get things off of people's brains and split decisions and to and all of those things. Then, you're going to encounter a different type of breakage which is simply like your business will become brittle and it will become resistant to growth. And you won't be able to lower and make those types of changes that you need to so interesting perspective on refactoring as well.

# **Context Switches**

[https://otter.ai/u/bfNZW9qc49o\_d6iVnnz5uI1Qocg?f=home](https://otter.ai/u/bfNZW9qc49o_d6iVnnz5uI1Qocg?f=home)

So one of the things that's really interesting to take a look at is this whole thing of context switching. ie, what happens when you are able to when you don't need a context switch and you're able to actually stay in one place, there's an efficiency gain. So how many different contexts is somebody required to operate it? How many different types of roles are they required? What how many different modalities are they required? If you can reduce those modalities down to the ones in which they're most efficient And certainly if you can eliminate the context switching. You you'll have an immediate gain now. You don't want to reduce context switches into over into a less efficient or less ideal scenario. This is another systems training.

# **Test-Driven Development**

New ideas

Test driven development

Unit tests

regression testing

If you look at the input and output, you'll see one part of the business that's always starved

If you're starved for leaders, it doesn't produce beyond

If you're starved on fulfillment staff…

# **Defragmentation**

●  	Defragmentation and/or refactoring

○  	Speed creates chaos

○  	You need to slow down to reorganize, or you’ll end up with spaghetti

●  	Diffing

○  	Add/remove

○  	Move \= remove/add (macro)

○  	Edit \= remove/add (micro)

# **Scripting vs Coding**

●  	Scripting/bash \- freelancers vs. entrepreneurs

●  	OOP \= business leadership

# **Lexical Analysis**

●  	Lexical analysis can tell you how an algorithm functions, but it does not inform the border context of how this software is used

## **Feedback Loops, Part 2**

[https://otter.ai/u/oczh53XUdlwHpVL5oBqUe5oO268](https://otter.ai/u/oczh53XUdlwHpVL5oBqUe5oO268)

Not every accountability structure in business is a feedback loop. So if you're starting with tactical delegation, tactical delegation by itself is a tight feedback loop where somebody else watches you, you know, if you wanted to go that way, pause, do model, then somebody watches you do it. And it's a really tight feedback loop, then you loosen it up and you watch them do it. And then you loosen it up and you go look at the results of what they produce. And then you loosen it up and you start monitoring the outcomes and you loosen it up and you start evaluating more and more. And then as as you go up your chart and further tree, you're, you've got greater cycles, feedback loops based on the reliability and the predictability of the system. So the less reliable a system is, the tighter feedback loops, you gotta have to automatically error Correct. Or if it's of low consequence, if it goes rogue or sideways, then you don't need a tight feedback loop. You can just let it go. You know, go where it wishes. The issue with you look at this as a sliding scale. So for example, if you have somebody who is rogue then you need to tighten the feedback loop. If they make a mistake, then you just need to implement a feedback loop. And if you're a micromanager and they're actually more reliable than what you think then you need to loosen up the feedback loop or expand it and, you know, allow more space and distance if it's actually dialed in and working and so understanding that from a concept of scalability and from a concept of delegation, layers of workshop is is a really helpful perspective of how to apply feedback loops in the business. And so the same thing happens with marketing tests. If you're doing a wild off the wall test, then you need tight feedback loops to make sure that it's actually working and if you're, if you're doing shore shot tests, then you can loosen it up. So maybe maybe you're tweaking though the 1% or something and you can you know, maybe maybe it takes less taken to close on that. Or, for example, you're testing a new product and you need really, really tight feedback loops. And that's why you encourage people to actually talk directly with customers. But then if you as it scales, then you can use looser feedback loops and you can put entire sales teams in place. And that's why, you know, that's why you don't want to mismatch, the scalability with the certainty so if you have a highly uncertain thing, you don't want to scale it because it it creates distance in the feedback loop and it creates a wild variance. Now, another observation, which I need to take take to heart is that any place where you see variance is a place where there's not reliability and predictability where there's not a process where and that's where you need feedback loops and you need to you not not only need feedback loops, you need systems and processes to implement and build those feedback loops. And there you go. That's it.

## **Firmware**

You have think about firmware, and the things that get flashed on firmware, and if it gets interrupted, you’re in trouble – just like what Stephanie was saying about the 67-day habits

# **Debugging**

https://otter.ai/u/ZQjVahwr2GfLlwDjJbkPJoiWmtA?f=home

An interesting perspective. The. When this came from starting to read the six month fix that was recommended by Tim Francis. You have a, you know, what are the rules of business? Well, the fundamental rule of business is you have to make money like this is the most practical irreducible rule of business. And there's 1,000,001 ways to do this. But if you violate this rule, well actually, that's not exactly true. In business, you have to have cash. And that's a rule you cannot violate. And if you violate it, that is the equivalent of an out of memory error or out of disk error or an exception. Crash. It's the end of the software running there's nothing more that can be done and that's the red line. Now normally, unless you're a venture startup, then you need something that produces profit, something highly profitable. For most freelancers, that's, you know, there's 1,000,001 ways to go about this.

And various ranges of certainty, but you need something that generates a profit this is one of the feedback loops that you want to optimize for.

to be completely clear, this is not the only one you should be optimizing for him. Because if you make this be the only one then you're going to might as well go sell drugs in the street corner. But there are other rules such as that actually feed into this. But it's kind of like running a compiler. And the compiler says it says, does it work? You know, there's some very basic does it work kinds of rules. If it doesn't work, and you get your debugger out, and you start breaking down the process, and you say, where in the process does this problem actually exist?

And if you can identify it where the problem exists. Think of your business as a subroutine. And first subroutine is marketing. How do you find people the second subroutine is sales How do you close business? Third subroutine is operations How do you fulfill on it for subroutine is referral and Ipsum Risa and if if, if the engine does not feed the engine free course so at this point, what you can do is you can start looking at where exactly is the problem, you can debug it. When you debug it, you can get call stack variables. You can say what exactly is what what is going on at this particular point in time. And effectively what you should think of it one one good way to think about it is as test driven development. And your goal is to maximize profitability in order to do create maximum benefit Yeah, so if you actually look at this from the standpoint of a compiler and pass pass fail results, then what follows from that is what does it take to actually build a compiler could you build a compiler for your business that looks at any given module, sub module and says, Is this thing functioning as it was intended to yes or no? And if yes, then everything is good. It is immediately an alert. It's the equivalent of a regression err, it's the equivalent of $1 Build error and requires immediate attention. Until this thing can be fully resolved. Follow up question and homework assignment is to literally implement something like this.

We've got step one and two. We got some initial accounting steps in place, but we really need to take it to one more level

## **Strategy Consulting through Process**

* What's the throughput? for example of a local business where people are moving through, and what they are buying. These are the inputs. How do you position yourself so that main street works? But even main street is part of a bigger process, where the world is shifting to online? And how do you follow that?

## **Profiling**

Two types of profiling

Decoration (iirc) Sampling

This is like getting feedback from customers and employees. You just need some time slices.

# More Thoughts

So I thought of two more things for my computer science book. One is offline usage, and then there's one that correlates to that, which is syncing. And then there's all of the other things like hardware, like monitors and the pixels and the three parts that make up each pixels and the RGBs. And uh, then there's things like RAM and temporary storage, which I think I might have talked about. But then there's also things like peripherals, like imagine the old cereal ports versus the, um, the, the cat, you know, cat five, cat six. Uh, then there's the standardization of usb, but then the different fragmentation within USB of different types of usb. Um, and then there's a fact that software comes down to information, decision making and actions. Um, and it's, you're really, really what you're doing is, I mean, ultimately at some form, all commands are a form of information, but, um, you know, more direct versus less direct information. So if somebody says, 

You 

Know, go to the hospital, I mean, in some ways it is a form of information, although it is in the form of a command. Um, another way to look at it is that there are real time and there are active and passive commands. So your speed should be this speed or, well, I don't know that this really makes sense. I'm kind of grappling with it. But, um, almost like this, well, what should I be doing now? What should I be doing now? What about now? What about now? Now, now, um, so there's, that's maybe a proactive versus a reactive response to commands. Um, I don't know. There's commands that are triggered by time, so that's another one. 

Okay.

## **TODO \- Declarative vs Imperative Languages**

Expression-Oriented Languages / Functional Languages vs. imperative programming

I think one of the things that arose from that is like, well, what is actual software because there's two ways that people think about software. What is people think about software from a very technical standpoint? In other words, you have a there there kind of are two types of even programming programming languages that are very linear, very, very, you know, step by step, the whole thing is a step by step. And that's called functional programming. Now, there's another way of programming which is like it will and those functional instructions are the foundation of any programming like I mean, yes, there are other types of expressive languages, expression based languages that are more you know, whatever, but be that as it may, at the core of all language and even you know,

# 2022-12-26 9:20 PM

Once you understand tree structures, you understand the formation of life.

For example, life begins with two people who have sex to conceive, and the process of growth continues as a series of divisions. We see this on a macro scale, where God divides himself into man (first of all), and since he was incapable of reproduction, subdivides man into man/woman. ANd we see it in the nature and structure of familes.

And everywhere we go, we see this.

In language parsers, you have a root object, that then gets subdivided into smaller pieces.

You have that with countries.

EVERYTHING in business starts with LIFE \-- with something that is working. ANd it grows and feeds from there. So if you want to find out what is going on and what is working, go START WITH THAT. Then allow that to expand.

Then, find everywhere that you are investing effort where it's not bearing fruit, and cut it off\!\! (This is good personal insight and feedback for how to respond to work.)

I don't feel like this captures the half of the significance of this line of thinking \-- but understanding how organisms form and grow is a good illustration of business.

For example, it is not healthy for a girl to become pregnant before she is capable of emotionally and physically caring for that child. Many "entrepreneurial seizures" (as Gerber calls them) could effectively be called "entrepreneurial orgasms" \-- that start things that later need to be aborted. Some business leaders need birth control on their ideas\! 

And a baby / offhsoot is akin to an embryo that (in some sense) is a parasite off the other. And you need to understand that new offshoots will cause the mother to become nauseous / sick / tired. ANd that to continually have one offshoot after another is going to wear down the mother's health and may eventually become a risk.

And that if those offshoots / startups are not properly trained, they will become a disgrace. They need attention, or they will become bratty children

And pruning is what is required (see above) to cut off the things that don't give life.

There is a major gap in women's view of business, and men's.

BTW, I could have a book on the concept, on markets, on business, etc. i.e. I could show this on a macro scale, as well as a very micro scale.

Even the framework that Tim Francis shared was an illustration of tree structure, and the dividing to create life. THere is a very specific order in which human organs form when a child is born.

The reason that the BMA ends up being abusive is that they discourage and stunt growth. It is like telling a child that their learning is complete, then punishing them if they try to learn anything else.

Also...

It is dysfunctional parenting to abandon a half-grown child for the sake of a one-night stand "grand idea" you have that will be the silver bullet for fixing your business. (This is NOT to say that businesses are children and shouldn't ever be abandoned.) However, if you imagine someone who has a five-year-old daughter, then pursues a lover for the sake of another daughter (abandoning the first one), you start to understand the depth of dysfunction that you experience in that space

Furthermoree...Talib says that creativity comes from unexpected interactions. This is what is happening when you have a sperm and an egg. They are bouncing around \-- it's unclear if they will meet \-- but they MIGHT and if they do, you have a fragile form of life that begins. If you want more kids you have more stirfry of ideas. If you want more adults, you better parent the ideas you've got. Etc etc

# Sales Call Reviews

When I was a software developer, we had an entire step in the development process that was devoted strictly to "code reviews". Whenever a developer made changes to the software, another developer (either a peer or a manager) would look over every part of that change. This happened long before anybody else got to use those changes.

These reviews included two parts:  
\- Is it **FUNCTIONALLY** correct? i.e. is it accurate in what it does?  
\- Is it **STYLISTICALLY** correct? i.e. is it well-structured and well-written?

In addition, each piece of feedback came with one of 3 levels of importance:  
\- This HAS to change.  
\- This SHOULD change.  
\- This COULD change.

We often offered subjective feedback to each other, even if it might not have been wrong. It helped us to broaden our scope and skillset.

**What does this have to do with sales call reviews?**

Unlike software, you can't go back and redo parts of sales calls. :-)  However, I would like to start doing weekly sales call reviews for a bit.

This simply means me going through your call recordings, listening, and making observations. I'm going to be looking for things that are going well and for things to consider for improvement.

By nature, some of these comments are going to be subjective. I'm going to include them anyway, and I invite you to consider them and to disagree and push back. I'm *very* interested in dialog, because I think that's one of the ways we get better.

I plan to be sending these out to you privately via email, starting today or tomorrow.

If you've got any questions, let me know.

Thanks for your patience as we get some of these management / coaching rhythms into play\!

