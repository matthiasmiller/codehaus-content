

| Speaker 1: | That's working. All right, here's another angle of this whole thing. Multi-threading, mute taxes, shared data, locks, race conditions, et cetera. Just a few observations that when you've got a lot of people working in the same type of environment and working on the same types of things, that they need to coordinate things so that they don't conflict on shared resources. This can create a constraint because not only does the shared resource create the problem, create a bottleneck, but the actual act of checking for the shared resources makes it a bottleneck. I'm going to give you a practical example. Let's say that you've got one truck for two guys. It's not just the fact that only one guy can be on the road at a time. It's the fact that each guy has to check to see whether the other guy's using the truck before he can actually use the truck.  |
| :---- | :---- |
|  | Now, in a digital world, if you're using something like Excel spreadsheets, for example, you have this same type of resource contention, is what it's called. You have one person who wants to use the Excel spreadsheet and the other person doesn't. Now you can just try to open the Excel spreadsheet, and that might be good enough. But even the fact that you might not be able to open the Excel document introduces delay, because you're already planning for contingencies of what if I'm actually not able to. Or if it doesn't, completely throws off sideways what you're trying to do.  |
|  | Taxes are basically a way to say, okay, you can simplify this by creating parameters around how often or when you actually do try to access the shared resource. Now, sometimes you can engineer your shared resource in such a way that there's only one person responsible for actually managing and updating the shared resource. Because they have limited bandwidth, it's a simple matter of sequencing an order. For example, in the vehicle example that I gave, the equivalent would be to have a dispatcher where they may get multiple requests in whatever form or mechanism that they want to prioritize it by, whether it's by first come, first served, or whether it's by other types of prioritization, they can manage access to the shared resource.  |
|  | Then ultimately, there's a final piece of this, which is there's a waiting that necessarily comes when you have a shared resource. While you might engage with other types of activities you still... The challenge is that when you've got multiple threads, you can very easily just tell them to wait until the shared resource is available. But from a human perspective, that's horribly inefficient.  |
|  | Ultimately what you have to do is do this from a systems perspective, so that you've got your notification, or something like that, that occurs when something becomes available. Call waiting, hold. These are examples of managing asynchronous communication because you've got a shared resource, i.e. either a person or a phone line, and you can either wait until the resource is available or get a call back.  |
|  | I guess along with that, there's synchronous waiting and asynchronous waiting, as in literally, this is called a callback. A great example again is customer service. When are you going to wait? Well, actually there's three ways to do this. One is I'm going to... there's synchronous waiting, there's event-driven notifications, and then there's pulling. Pulling just means I'm going to check, check, check, check, check until it's done. Now the problem with that, well... Along with that, there's also timeout typically with any type of waiting, perhaps not with event-driven, but let's say that you've got an email that you send and you don't get a response.  |
|  | Well, clearly it's not a logical approach to simply wait until you get a response. That means that you're either waiting for an event driven or pulling type of response. With this, there's also the concept of timeout. Let's say that you pull, which means that you periodically check back in and say, hey, did I get an email? If not, you might actually ping them and say, hey, can I have an answer to my email? you continue this. Event driven, you simply wait for the response to come back.  |
|  | In the example of Google, it comes back to you after two days, or three days, and you haven't gotten a response. So this guarantees some kind of timeout on the responses to your email messages. This is one of the ways that you prevent system failure, or that you protect against it. Because the question is, how do you protect against things when they go completely dark? Well, you need contingencies for that. What happens when somebody's on hold for 10 minutes and how do you know they didn't just get stranded? You ring them back into the main queue and you prioritize them to the top of the queue and it rings again, you talk to somebody who's more likely to be available and it says, hey, answer this call.  |

